中文目录只做说明，不能放代码，放进来干死你

对于蓝牙，首先使用的是外部库bleak
# —————————————————关于异步函数的说明————开始——————————————
这里需要强调函数的不同
我们将会看见异步函数
# 普通函数
def my_function():
    result = do_something()
    return result

# 异步函数
async def my_async_function():
    result = await do_something_async()
    return result

在上述示例中，my_function() 是一个普通函数，而 my_async_function() 是一个异步函数。在异步函数中，可以使用 await 关键字等待一个异步操作的完成，这里的 do_something_async() 就是一个异步操作。
需要注意的是，异步函数在调用时会返回一个协程对象，需要通过事件循环（event loop）来执行。你可以使用 asyncio.run() 函数或其他事件循环机制来运行异步函数。
也就是说如果要运行异步函数就需要asyncio.run(异步函数)这样来运行。这就是二者的区别
第一，定义上的区别 def与async def
第二，使用的区别调用函数需要await的前提，同时需要asyncio.run() 来运行异步函数。


异步函数的一个关键特性是它们可以在等待某个操作完成的同时继续执行其他任务。当一个异步函数遇到一个耗时的操作时，它可以使用 await 关键字将控制权交给事件循环，并在操作完成后再继续执行。

异步函数通常用于处理那些可能会阻塞主线程或需要等待的操作，例如网络请求、文件 I/O、数据库查询等。通过将这些操作转换为异步操作，可以避免阻塞整个程序的执行，提高程序的并发性能。
以下是一个示例，展示了异步函数不使用 await 导致事件循环一直运行的情况：
import asyncio

async def my_async_function():
    print("Start")
    # 缺少 await 关键字
    time.sleep(5)
    print("End")

asyncio.run(my_async_function())
在这个例子中，由于没有使用 await 关键字来等待 time.sleep(5) 的完成，事件循环会一直等待这个操作完成，导致函数无法继续执行下去。修复这个问题的方法是将 time.sleep(5) 替换为 await asyncio.sleep(5)，以确保正确地等待异步操作的完成。
正确的示例代码如下：
import asyncio

async def my_async_function():
    print("Start")
    await asyncio.sleep(5)
    print("End")

asyncio.run(my_async_function())

在这个修复后的示例中，await asyncio.sleep(5) 会正确地等待 5 秒钟的异步操作完成，然后函数会继续执行并打印 "End"。

# —————————————————关于异步函数的说明————结束——————————————
# —————————————————对于蓝牙模块的说明—————开始——————————————
对蓝牙要有一个认识，可以先看文件blue tooth.py
然后如果需要对蓝牙发送扫描指令可以看文件bluetooth_only_send.py

# —————————————————对于蓝牙模块的说明—————结束——————————————


